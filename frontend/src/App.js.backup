import React, { useState, useEffect, useCallback } from "react";
import { Routes, Route, useNavigate, useLocation } from "react-router-dom";
import {
  Box, CssBaseline, AppBar, Toolbar, IconButton, Typography, Drawer, List, ListItem, ListItemIcon,
  ListItemText, Divider, useTheme, useMediaQuery, Paper, Snackbar, CircularProgress, Dialog,
  DialogTitle, DialogContent, DialogActions, Button, Tabs, Tab, FormControl, Select, MenuItem, 
  InputBase, Chip, Card, CardContent, Collapse, Switch, FormControlLabel, Pagination, Tooltip,
  Badge, Fab, Table, TableHead, TableBody, TableRow, TableCell, Grid, TextField,
  Alert, Skeleton
} from "@mui/material";
import {
  Dashboard as DashboardIcon,
  TrendingUp as TrendingUpIcon,
  Settings as SettingsIcon,
  SmartToy as AIIcon,
  Notifications as NotificationsIcon,
  Assessment as AssessmentIcon,
  SettingsInputAntenna as SettingsInputAntennaIcon,
  Security as SecurityIcon,
  AutoAwesome as AutoAwesomeIcon,
  ManageAccounts as ManageAccountsIcon,
  Reviews as ReviewsIcon,
  Key as KeyIcon,
  Analytics as AnalyticsIcon,
  MonitorHeart as MonitorHeartIcon,
  Api as ApiIcon,
  QrCode as QrCodeIcon,
  Info as InfoIcon,
  Flag as FlagIcon,
  Attachment as AttachmentIcon,
  Visibility as VisibilityIcon,
  MoreVert as MoreVertIcon,
  ExpandLess as ExpandLessIcon,
  ExpandMore as ExpandMoreIcon,
  Close as CloseIcon,
  FilterList as FilterListIcon,
  Refresh as RefreshIcon,
  GetApp as ExportIcon,
  Error as ErrorIcon,
  CheckCircle as CheckCircleIcon,
  Menu as MenuIcon,
  Search as SearchIcon,
  Image as ImageIcon,
  VideoFile as VideoIcon,
  AudioFile as AudioIcon,
  Description as DocumentIcon
} from '@mui/icons-material';
import io from "socket.io-client";
import { createTheme, ThemeProvider, styled } from "@mui/material/styles";
import axios from "axios";
import Sidebar from "./components/Sidebar";
import Header from "./components/Header";
import MessageDetailModal from "./components/MessageDetailModal";
import ConfirmationModal from "./components/ConfirmationModal";
import AnalyticsModal from "./components/AnalyticsModal";
import FiltersPanel from "./components/FiltersPanel";
import MessageActions from "./components/MessageActions";
import NotificationToast from "./components/NotificationToast";
import AnalyticsPage from "./components/AnalyticsPage";
import SlackIntegrationPage from "./components/SlackIntegrationPage";
import DigestPage from "./components/DigestPage";
import KeywordAnalyticsPage from './components/KeywordAnalyticsPage';
import FlagKeywordsPage from './components/FlagKeywordsPage';
import KeywordReviewPage from './components/KeywordReviewPage';
import IssueCategoriesPage from './components/IssueCategoriesPage';
import ComprehensiveAnalyticsDashboard from './components/ComprehensiveAnalyticsDashboard';
import WhatsAppRoutingPage from './components/WhatsAppRoutingPage';
import AIConfidenceManagement from './components/AIConfidenceManagement';
import DynamicCategoriesPage from './components/DynamicCategoriesPage';
import AIDashboardPage from './components/AIDashboardPage';
import ManualLabelingPage from './components/ManualLabelingPage';
import AutoHealerPage from './components/AutoHealerPage';
import UserInteractionLogger from './components/UserInteractionLogger';
import UserInteractionLogsPage from './components/UserInteractionLogsPage';
import LogViewerPage from './components/LogViewerPage';
import EndpointsPage from './components/EndpointsPage';
import DashboardHealthMonitor from './components/DashboardHealthMonitor';
import AIIntelligencePage from './components/AIIntelligencePage';
import LiveConsole from './components/LiveConsole';

// Global Frontend Logging System
import logFrontend, { logDebug, logInfo, logWarn, logError } from './utils/logger';
import {
  LineChart, Line, AreaChart, Area, BarChart, Bar, PieChart, Pie, Cell,
  XAxis, YAxis, CartesianGrid, Tooltip as RechartsTooltip, Legend, ResponsiveContainer
} from 'recharts';
// Removed date-fns imports - no longer needed for date filtering

// WTF Brand Colors
const BRAND_COLORS = {
  red: '#E50012',
  darkGray: '#374151',
  mediumGray: '#6B7280',
  lightGray: '#F9FAFB',
  white: '#FFFFFF',
  green: '#10B981',
  shadow: 'rgba(0, 0, 0, 0.1)',
  border: 'rgba(0, 0, 0, 0.08)',
  sidebarBg: 'linear-gradient(180deg, #FFFFFF 0%, #F8FAFC 100%)'
};

const SIDEBAR_WIDTH = 280;
const SIDEBAR_COLLAPSED_WIDTH = 60;
const ITEMS_PER_PAGE = 100; // Increased from 25 to 100
const MAX_INFINITE_SCROLL_ITEMS = 1000; // After 1000 items, switch to pagination
const INFINITE_SCROLL_LOAD_SIZE = 100; // Load 100 items at a time during infinite scroll

const NAV_ITEMS = [
  { label: "Dashboard", key: "dashboard", icon: <DashboardIcon /> },
  { label: "All Messages", key: "messages", icon: <DashboardIcon /> },
  { label: "Flagged Messages", key: "flagged", icon: <FlagIcon /> },
  { label: "Analytics", key: "analytics", icon: <TrendingUpIcon /> },
  { label: "AI Dashboard", key: "ai_dashboard", icon: <AIIcon /> },
  { label: "ðŸ§  AI Intelligence", key: "ai_intelligence", icon: <AIIcon /> },
  { label: "ðŸ§  AI Manual Labeling", key: "ai_labeling", icon: <AIIcon /> },
  { label: "ðŸ¤– Auto-Healer AI", key: "auto_healer", icon: <AIIcon /> },
  { label: "Daily/Weekly Digest", key: "digest", icon: <AssessmentIcon /> },
  { label: "Slack Integration", key: "slack", icon: <NotificationsIcon /> },
  { label: "WhatsApp Routing", key: "whatsapp_routing", icon: <SettingsInputAntennaIcon /> },
        { label: "AI Confidence Management", key: "ai_confidence", icon: <SecurityIcon /> },
      { label: "Dynamic Categories", key: "dynamic_categories", icon: <AutoAwesomeIcon /> },
  { label: "Issue Management", key: "issue_management", icon: <ManageAccountsIcon /> },
  { label: "Keyword Review", key: "keyword_review", icon: <ReviewsIcon /> },
  { label: "Flag Keywords", key: "flag_keywords", icon: <KeyIcon /> },
  { label: "Keyword Analytics", key: "keyword_analytics", icon: <AnalyticsIcon /> },
  { label: "User Interaction Logs", key: "interaction_logs", icon: <AnalyticsIcon /> },
  { label: "Development Log Viewer", key: "log-viewer", icon: <AnalyticsIcon /> },
  { label: "Health Monitor", key: "health_monitor", icon: <MonitorHeartIcon /> },
  { label: "API Endpoints", key: "endpoints", icon: <ApiIcon /> },
  { label: "System Status", key: "status", icon: <SettingsInputAntennaIcon /> },
  { label: "WhatsApp QR", key: "qr", icon: <QrCodeIcon /> },
  { label: "About", key: "about", icon: <InfoIcon /> },
];

const SOCKET_URL = window.location.origin;

const theme = createTheme({
  palette: {
    mode: "light",
    primary: { main: BRAND_COLORS.red },
    secondary: { main: BRAND_COLORS.green },
    background: { default: BRAND_COLORS.lightGray, paper: BRAND_COLORS.white },
    text: { primary: BRAND_COLORS.darkGray, secondary: BRAND_COLORS.mediumGray }
  },
  typography: { 
    fontFamily: "'Inter', 'Segoe UI', 'Roboto', 'Helvetica', 'Arial', sans-serif",
    h6: { fontWeight: 600, fontSize: '1.1rem' },
    h5: { fontWeight: 700, fontSize: '1.3rem' },
    h4: { fontWeight: 700, fontSize: '1.5rem' },
    body1: { fontSize: '0.95rem', lineHeight: 1.6 },
    body2: { fontSize: '0.85rem', lineHeight: 1.5 }
  },
  shape: { borderRadius: 12 },
  shadows: [
    'none',
    `0 1px 3px ${BRAND_COLORS.shadow}`,
    `0 4px 6px ${BRAND_COLORS.shadow}`,
    `0 10px 15px ${BRAND_COLORS.shadow}`,
    ...Array(21).fill(`0 10px 25px ${BRAND_COLORS.shadow}`)
  ],
  components: {
    MuiCssBaseline: {
      styleOverrides: {
        '@global': {
          '@keyframes pulse': {
            '0%': { opacity: 1 },
            '50%': { opacity: 0.5 },
            '100%': { opacity: 1 }
          },
          '@keyframes slideInLeft': {
            '0%': { transform: 'translateX(-20px)', opacity: 0 },
            '100%': { transform: 'translateX(0)', opacity: 1 }
          },
          '@keyframes fadeInUp': {
            '0%': { transform: 'translateY(10px)', opacity: 0 },
            '100%': { transform: 'translateY(0)', opacity: 1 }
          },
          '@keyframes bounce': {
            '0%, 20%, 53%, 80%, 100%': { transform: 'translateY(0)' },
            '40%, 43%': { transform: 'translateY(-8px)' },
            '70%': { transform: 'translateY(-4px)' },
            '90%': { transform: 'translateY(-2px)' }
          }
        }
      }
    }
  }
});

const StyledSidebar = styled(Box)(({ theme, open }) => ({
  width: open ? SIDEBAR_WIDTH : 0,
  height: '100vh',
  position: 'fixed',
  left: 0,
  top: 0,
  background: BRAND_COLORS.sidebarBg,
  borderRight: `1px solid ${BRAND_COLORS.border}`,
  zIndex: 1300,
  display: 'flex',
  flexDirection: 'column',
  transition: 'width 0.3s cubic-bezier(0.4, 0, 0.2, 1)',
  overflow: 'hidden',
  boxShadow: open ? `4px 0 12px ${BRAND_COLORS.shadow}` : 'none'
}));

const SidebarOverlay = styled(Box)(({ theme, open }) => ({
  position: 'fixed',
  top: 0,
  left: 0,
  width: '100vw',
  height: '100vh',
  backgroundColor: 'rgba(0, 0, 0, 0.3)',
  zIndex: 1250,
  display: open ? 'block' : 'none',
  transition: 'opacity 0.3s ease'
}));

const StyledNavItem = styled(ListItem)(({ theme, active }) => ({
  margin: '2px 12px',
  borderRadius: 10,
  padding: '10px 16px',
  cursor: 'pointer',
  transition: 'all 0.2s cubic-bezier(0.4, 0, 0.2, 1)',
  position: 'relative',
  minHeight: 48,
  '&:hover': {
    backgroundColor: active ? BRAND_COLORS.red : 'rgba(229, 0, 18, 0.08)',
    transform: 'translateX(2px)'
  },
  ...(active && {
    backgroundColor: BRAND_COLORS.red,
    color: BRAND_COLORS.white,
    boxShadow: `0 4px 12px rgba(229, 0, 18, 0.4)`,
    '&::before': {
      content: '""',
      position: 'absolute',
      left: -12,
      top: 0,
      height: '100%',
      width: 4,
      backgroundColor: BRAND_COLORS.red,
      borderRadius: '0 4px 4px 0'
    }
  })
}));

const StyledCard = styled(Card)(({ theme }) => ({
  borderRadius: 16,
  boxShadow: `0 1px 3px ${BRAND_COLORS.shadow}`,
  border: `1px solid ${BRAND_COLORS.border}`,
  transition: 'all 0.3s ease',
  backgroundColor: BRAND_COLORS.white,
  '&:hover': {
    boxShadow: `0 4px 12px ${BRAND_COLORS.shadow}`,
    transform: 'translateY(-1px)'
  }
}));

const StyledTab = styled(Tab)(({ theme }) => ({
  fontWeight: 600,
  fontSize: '1.1rem',
  textTransform: 'none',
  minWidth: 180,
  padding: '16px 32px',
  color: BRAND_COLORS.darkGray,
  borderRadius: '12px 12px 0 0',
  marginRight: '4px',
  transition: 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)',
  '&.Mui-selected': {
    color: BRAND_COLORS.red,
    fontWeight: 700,
    backgroundColor: 'rgba(229, 0, 18, 0.04)'
  },
  '&:hover': {
    backgroundColor: 'rgba(229, 0, 18, 0.04)'
  }
}));

const StyledBadge = styled(Chip)(({ status }) => ({
  fontWeight: 600,
  fontSize: '0.75rem',
  height: 28,
  borderRadius: 14,
  ...(status === 'connected' && {
    backgroundColor: BRAND_COLORS.green,
    color: BRAND_COLORS.white
  }),
  ...(status === 'disconnected' && {
    backgroundColor: BRAND_COLORS.red,
    color: BRAND_COLORS.white
  }),
  ...(status === 'neutral' && {
    backgroundColor: BRAND_COLORS.mediumGray,
    color: BRAND_COLORS.white
  }),
  ...(status === 'positive' && {
    backgroundColor: BRAND_COLORS.green,
    color: BRAND_COLORS.white
  }),
  ...(status === 'negative' && {
    backgroundColor: BRAND_COLORS.red,
    color: BRAND_COLORS.white
  })
}));

const SearchInput = styled(InputBase)(({ theme }) => ({
  backgroundColor: BRAND_COLORS.white,
  borderRadius: 10,
  padding: '10px 16px',
  fontSize: '0.9rem',
  width: '100%',
  border: `1px solid ${BRAND_COLORS.border}`,
  transition: 'all 0.2s ease',
  '&:hover': {
    borderColor: BRAND_COLORS.red,
    boxShadow: `0 0 0 2px rgba(229, 0, 18, 0.1)`
  },
  '&.Mui-focused': {
    borderColor: BRAND_COLORS.red,
    boxShadow: `0 0 0 3px rgba(229, 0, 18, 0.15)`
  }
}));

const TableContainer = styled(Box)(({ theme }) => ({
  backgroundColor: BRAND_COLORS.white,
  borderRadius: 12,
  overflow: 'hidden',
  border: `1px solid ${BRAND_COLORS.border}`,
  '& table': {
    width: '100%',
    borderCollapse: 'collapse',
    '& th': {
      backgroundColor: BRAND_COLORS.lightGray,
      padding: '16px 20px',
      fontWeight: 700,
      fontSize: '0.85rem',
      color: BRAND_COLORS.darkGray,
      borderBottom: `1px solid ${BRAND_COLORS.border}`,
      textAlign: 'left',
      whiteSpace: 'nowrap',
      position: 'sticky',
      top: 0,
      zIndex: 10
    },
    '& td': {
      padding: '16px 20px',
      fontSize: '0.85rem',
      borderBottom: `1px solid ${BRAND_COLORS.border}`,
      verticalAlign: 'top',
      lineHeight: 1.5
    },
    '& tbody tr': {
      transition: 'all 0.15s ease',
      '&:nth-of-type(even)': {
        backgroundColor: 'rgba(249, 250, 251, 0.5)'
      },
      '&:hover': {
        backgroundColor: 'rgba(229, 0, 18, 0.04)',
        transform: 'scale(1.001)',
        boxShadow: `0 2px 8px ${BRAND_COLORS.shadow}`
      },
      '&:last-child td': {
        borderBottom: 'none'
      }
    }
  }
}));

const StyledHeader = styled(Box)(({ theme, sidebarOpen }) => ({
  position: 'sticky',
  top: 0,
  zIndex: 100,
  backgroundColor: BRAND_COLORS.white,
  borderBottom: `1px solid ${BRAND_COLORS.border}`,
  marginLeft: sidebarOpen && !theme.breakpoints.down("lg") ? SIDEBAR_WIDTH : 0,
  transition: 'margin-left 0.3s cubic-bezier(0.4, 0, 0.2, 1)',
  boxShadow: `0 1px 3px ${BRAND_COLORS.shadow}`
}));

// Media Icon Component with processing status
const MediaIcon = ({ mediaType, hasMedia, mediaSize, mediaFilename, processingStatus }) => {
  if (!hasMedia) return null;
  
  const getMediaIcon = () => {
    switch (mediaType?.toLowerCase()) {
      case 'image':
        return 'ðŸ“·';
      case 'video':
        return 'ðŸŽ¥';
      case 'audio':
        return 'ðŸŽµ';
      case 'application':
      case 'document':
        return 'ðŸ“„';
      default:
        return 'ðŸ“Ž';
    }
  };

  const getStatusColor = () => {
    if (!mediaFilename || processingStatus === 'processing') {
      return 'rgba(255, 152, 0, 0.1)'; // Orange for processing
    }
    if (mediaFilename?.includes('FAILED:')) {
      return 'rgba(244, 67, 54, 0.1)'; // Red for failed
    }
    return 'rgba(25, 118, 210, 0.1)'; // Blue for ready
  };

  const getStatusText = () => {
    if (!mediaFilename || processingStatus === 'processing') {
      return 'Processing...';
    }
    if (mediaFilename?.includes('FAILED:')) {
      return 'Failed';
    }
    return 'Ready';
  };

  return (
    <Box sx={{ 
      display: 'inline-flex', 
      alignItems: 'center', 
      mr: 1,
      backgroundColor: getStatusColor(),
      borderRadius: '4px',
      px: 0.5,
      py: 0.25,
      border: !mediaFilename ? '1px dashed rgba(255, 152, 0, 0.5)' : 'none'
    }}>
      <Typography sx={{ fontSize: '14px', mr: 0.5 }}>
        {getMediaIcon()}
      </Typography>
      {!mediaFilename || processingStatus === 'processing' ? (
        <CircularProgress size={12} sx={{ color: '#ff9800' }} />
      ) : mediaFilename?.includes('FAILED:') ? (
        <ErrorIcon sx={{ fontSize: '12px', color: '#f44336' }} />
      ) : (
        <CheckCircleIcon sx={{ fontSize: '12px', color: '#4caf50' }} />
      )}
      <Typography sx={{ fontSize: '10px', ml: 0.5, color: 'text.secondary' }}>
        {getStatusText()}
      </Typography>
    </Box>
  );
};

// Expandable Message Component
const ExpandableMessage = ({ message, hasMedia, mediaType, maxLength = 50 }) => {
  const [isExpanded, setIsExpanded] = useState(false);
  
  const formatMessage = (message, hasMedia, mediaType) => {
    if (hasMedia) {
      if (!message || message === '[No Text]') {
        const mediaTypeText = mediaType ? mediaType.toUpperCase() : 'MEDIA';
        return `ðŸ“Ž ${mediaTypeText} ATTACHMENT`;
      } else {
        // Message with media
        return `${message} ðŸ“Ž`;
      }
    }
    return message || '[No Text]';
  };

  const formattedMessage = formatMessage(message, hasMedia, mediaType);
  const shouldTruncate = formattedMessage.length > maxLength;
  const displayMessage = isExpanded || !shouldTruncate 
    ? formattedMessage 
    : `${formattedMessage.substring(0, maxLength)}...`;

  return (
    <Box>
      <Typography variant="body2" sx={{ 
        wordBreak: 'break-word',
        whiteSpace: isExpanded ? 'normal' : 'nowrap',
        overflow: isExpanded ? 'visible' : 'hidden',
        textOverflow: isExpanded ? 'clip' : 'ellipsis',
        maxWidth: isExpanded ? 'none' : 300
      }}>
        {displayMessage}
      </Typography>
      {shouldTruncate && (
        <Button
          size="small"
          variant="text"
          sx={{ 
            fontSize: '0.75rem', 
            p: 0, 
            minWidth: 'auto', 
            color: 'primary.main',
            textTransform: 'none'
          }}
          onClick={() => setIsExpanded(!isExpanded)}
        >
          {isExpanded ? 'View Less' : 'View More'}
        </Button>
      )}
    </Box>
  );
};

// Enhanced Message Row Component
const MessageRow = ({ row, onView, onFlag, onEscalate }) => {
  const getSentimentColor = (sentiment) => {
    if (!sentiment) return 'default';
    switch (sentiment.toLowerCase()) {
      case 'positive': return 'success';
      case 'negative': return 'error';
      case 'neutral': return 'info';
      default: return 'default';
    }
  };

  const formatMessage = (message, hasMedia, mediaType) => {
    if (hasMedia) {
      if (!message || message === '[No Text]') {
        const mediaTypeText = mediaType ? mediaType.toUpperCase() : 'MEDIA';
        return `ðŸ“Ž ${mediaTypeText} ATTACHMENT`;
      } else {
        // Message with media
        return `${message} ðŸ“Ž`;
      }
    }
    return message || '[No Text]';
  };

  return (
    <TableRow hover>
      <TableCell>
        <Typography variant="body2" color="text.secondary">
          {new Date(row.received_at).toLocaleString()}
        </Typography>
      </TableCell>
      <TableCell>
        <Typography variant="body2" color="text.secondary">
          {row.group_name || 'Direct Message'}
        </Typography>
      </TableCell>
      <TableCell>
        <Box>
          <Typography variant="body2" fontWeight="medium">
            {row.sender_name || 'Unknown'}
          </Typography>
          <Typography variant="caption" color="text.secondary">
            {row.number}
          </Typography>
        </Box>
      </TableCell>
      <TableCell>
        <Box display="flex" alignItems="center">
          <MediaIcon mediaType={row.media_type} hasMedia={row.has_media} mediaSize={row.media_size} mediaFilename={row.media_filename} processingStatus={row.processing_status} />
          <ExpandableMessage message={row.message} hasMedia={row.has_media} mediaType={row.media_type} />
        </Box>
      </TableCell>
      <TableCell>
        <Box display="flex" gap={0.5}>
          {row.sentiment && (
            <Chip 
              label={row.sentiment} 
              size="small" 
              color={getSentimentColor(row.sentiment)}
            />
          )}
          {row.has_media && (
            <Chip 
              label="MEDIA" 
              size="small" 
              color="info"
              icon={<AttachmentIcon />}
            />
          )}
        </Box>
      </TableCell>
      <TableCell>
        <Box display="flex" gap={1}>
          <Button
            size="small"
            variant="outlined"
            onClick={() => onView(row)}
          >
            View
          </Button>
          <Button
            size="small"
            variant="outlined"
            color="warning"
            onClick={() => onFlag(row)}
          >
            Flag
          </Button>
          <Button
            size="small"
            variant="outlined"
            color="error"
            onClick={() => onEscalate(row)}
          >
            Escalate
          </Button>
        </Box>
      </TableCell>
    </TableRow>
  );
};

// Enhanced Flagged Message Row Component
const FlaggedMessageRow = ({ row, onView, onUnflag, onEscalate }) => {
  const getSeverityColor = (flagReason) => {
    if (!flagReason) return 'default';
    const reason = flagReason.toLowerCase();
    if (reason.includes('urgent') || reason.includes('angry')) return 'error';
    if (reason.includes('negative') || reason.includes('complaint')) return 'warning';
    return 'info';
  };

  const formatMessage = (message, hasMedia, mediaType) => {
    if (hasMedia && (!message || message === '[No Text]')) {
      return `ðŸ“Ž ${mediaType?.toUpperCase() || 'MEDIA'} ATTACHMENT`;
    }
    return message || '[No Text]';
  };

  return (
    <TableRow hover>
      <TableCell>
        <Typography variant="body2" color="text.secondary">
          {new Date(row.received_at).toLocaleString()}
        </Typography>
      </TableCell>
      <TableCell>
        <Typography variant="body2" color="text.secondary">
          {row.group_name || 'Direct Message'}
        </Typography>
      </TableCell>
      <TableCell>
        <Box>
          <Typography variant="body2" fontWeight="medium">
            {row.sender_name || 'Unknown'}
          </Typography>
          <Typography variant="caption" color="text.secondary">
            {row.number}
          </Typography>
        </Box>
      </TableCell>
      <TableCell>
        <Box display="flex" alignItems="center">
          <MediaIcon mediaType={row.media_type} hasMedia={row.has_media} mediaSize={row.media_size} mediaFilename={row.media_filename} processingStatus={row.processing_status} />
          <ExpandableMessage message={row.message} hasMedia={row.has_media} mediaType={row.media_type} />
        </Box>
      </TableCell>
      <TableCell>
        <Box display="flex" gap={0.5} flexWrap="wrap">
          {row.flag_reason && (
            <Chip 
              label={row.flag_reason} 
              size="small" 
              color={getSeverityColor(row.flag_reason)}
            />
          )}
          {row.has_media && (
            <Chip 
              label="MEDIA" 
              size="small" 
              color="info"
              icon={<AttachmentIcon />}
            />
          )}
        </Box>
      </TableCell>
      <TableCell>
        <Box display="flex" gap={1}>
          <Button
            size="small"
            variant="outlined"
            onClick={() => onView(row)}
          >
            View
          </Button>
          <Button
            size="small"
            variant="outlined"
            color="success"
            onClick={() => onUnflag(row)}
          >
            Unflag
          </Button>
          <Button
            size="small"
            variant="outlined"
            color="error"
            onClick={() => onEscalate(row)}
          >
            Escalate
          </Button>
        </Box>
      </TableCell>
    </TableRow>
  );
};

export default function App() {
  const navigate = useNavigate();
  const location = useLocation();
  
  // Global Frontend Logging Setup
  useEffect(() => {
    // Proxy console methods to capture all console output
    const originalLog = console.log;
    const originalWarn = console.warn;
    const originalError = console.error;
    const originalDebug = console.debug;

    console.log = (...args) => {
      originalLog(...args);
      logFrontend({
        level: 'info',
        source: 'console.log',
        message: args.join(' '),
        data: { args }
      });
    };

    console.warn = (...args) => {
      originalWarn(...args);
      logFrontend({
        level: 'warn',
        source: 'console.warn',
        message: args.join(' '),
        data: { args }
      });
    };

    console.error = (...args) => {
      originalError(...args);
      logFrontend({
        level: 'error',
        source: 'console.error',
        message: args.join(' '),
        data: { args },
        immediate: true
      });
    };

    console.debug = (...args) => {
      originalDebug(...args);
      logFrontend({
        level: 'debug',
        source: 'console.debug',
        message: args.join(' '),
        data: { args }
      });
    };

    // Global error handler
    window.addEventListener('error', (event) => {
      logError('window.onerror', `${event.message} at ${event.filename}:${event.lineno}`, {
        error: event.error,
        filename: event.filename,
        lineno: event.lineno,
        colno: event.colno
      });
    });

    // Unhandled promise rejection handler
    window.addEventListener('unhandledrejection', (event) => {
      logError('window.unhandledrejection', `Unhandled promise rejection: ${event.reason}`, {
        reason: event.reason,
        promise: event.promise
      });
    });

    // Log app initialization
    logInfo('App', 'Frontend logging system initialized', {
      userAgent: navigator.userAgent,
      url: window.location.href,
      timestamp: new Date().toISOString()
    });

    return () => {
      // Restore original console methods on cleanup
      console.log = originalLog;
      console.warn = originalWarn;
      console.error = originalError;
      console.debug = originalDebug;
    };
  }, []);
  
  // Get current view from URL path
  const getCurrentView = () => {
    const path = location.pathname.slice(1) || 'messages';
    return path;
  };
  
  const [currentView, setCurrentView] = useState(getCurrentView());
  const [currentTab, setCurrentTab] = useState("logs");
  const [sidebarOpen, setSidebarOpen] = useState(false); // ALWAYS start closed
  const [sidebarCollapsed, setSidebarCollapsed] = useState(false);
  const [filtersOpen, setFiltersOpen] = useState(false);
  const [alert, setAlert] = useState("");
  const [aboutOpen, setAboutOpen] = useState(false);
  const [page, setPage] = useState(1);

  const [logs, setLogs] = useState([]);
  const [flags, setFlags] = useState([]);
  const [allLogs, setAllLogs] = useState([]);
  const [allFlags, setAllFlags] = useState([]);
  const [groupFilter, setGroupFilter] = useState("");
  const [senderFilter, setSenderFilter] = useState("");
  const [search, setSearch] = useState("");
  const [realtime, setRealtime] = useState(true);
  const [loading, setLoading] = useState(false);
  const [newMessageCount, setNewMessageCount] = useState(0);
  const [recentMessages, setRecentMessages] = useState([]);
  const [notification, setNotification] = useState({ open: false, message: '', type: 'message', count: 0 });

  // Enhanced pagination and filtering state
  const [isInfiniteScroll, setIsInfiniteScroll] = useState(true);
  const [infiniteScrollData, setInfiniteScrollData] = useState([]);
  const [hasMoreData, setHasMoreData] = useState(true);
  const [loadingMore, setLoadingMore] = useState(false);
    const [totalMessages, setTotalMessages] = useState(0);

  // ENHANCED: WebSocket connection management
  const [connectionStatus, setConnectionStatus] = useState('connecting');
  const [connectionLatency, setConnectionLatency] = useState(0);
  const [wasDisconnected, setWasDisconnected] = useState(false);
  const [pendingAICount, setPendingAICount] = useState(0);

  const [keywordReview, setKeywordReview] = useState([]);
  const [staticKeywords, setStaticKeywords] = useState([]);
  const [keywordAnalytics, setKeywordAnalytics] = useState([]);
  const [slackAlerts, setSlackAlerts] = useState([]);

  // Analytics filters
  const [analyticsDateRange, setAnalyticsDateRange] = useState('7');
  const [analyticsLocation, setAnalyticsLocation] = useState('');
  const [analyticsCategory, setAnalyticsCategory] = useState('');
  const [analyticsTimeframe, setAnalyticsTimeframe] = useState('daily');
  
  const [waStatus, setWaStatus] = useState('Loading...');

  // Modal states
  const [selectedMessage, setSelectedMessage] = useState(null);
  const [messageDetailOpen, setMessageDetailOpen] = useState(false);
  const [confirmationModal, setConfirmationModal] = useState({ open: false, action: null, data: null });
  const [analyticsModal, setAnalyticsModal] = useState({ open: false, title: '', metricType: '', value: 0 });
  const [actionLoading, setActionLoading] = useState(false);

  const muiTheme = useTheme();
  const isMobile = useMediaQuery(muiTheme.breakpoints.down("lg"));

  // Force sidebar to be closed on initial load
  useEffect(() => {
    console.log('ðŸ”’ Forcing sidebar closed on initial load');
    setSidebarOpen(false);
  }, []); // Empty dependency array - runs only once on mount

  // Auto-collapse sidebar on mobile
  useEffect(() => {
    if (isMobile) {
      setSidebarOpen(false);
    }
    // Don't auto-open sidebar on desktop - let user control it manually
  }, [isMobile]);

  // Calculate sidebar width based on state
  const getSidebarWidth = () => {
    if (!sidebarOpen) return 0;
    if (isMobile) return 0; // Mobile sidebar is overlay
    return sidebarCollapsed ? SIDEBAR_COLLAPSED_WIDTH : SIDEBAR_WIDTH;
  };

  // Calculate main content margin
  const getMainContentMargin = () => {
    if (isMobile) return 0; // Mobile sidebar is overlay
    if (!sidebarOpen) return 0; // Sidebar closed = no margin
    return getSidebarWidth();
  };

  // Group recent messages (last 5 minutes)
  useEffect(() => {
    const now = new Date();
    const fiveMinutesAgo = new Date(now.getTime() - 5 * 60 * 1000);
    
    const recent = allLogs.filter(msg => {
      const msgTime = new Date(msg.received_at);
      return msgTime > fiveMinutesAgo;
    });
    
    setRecentMessages(recent);
    if (recent.length > newMessageCount) {
      setNotification({
        open: true,
        message: `${recent.length - newMessageCount} new messages received`,
        type: 'message',
        count: recent.length - newMessageCount
      });
    }
    setNewMessageCount(recent.length);
  }, [allLogs, newMessageCount]);

  // Data processing - apply filtering and pagination
  const allRows = currentTab === "logs" ? allLogs : allFlags;
  
  // CRITICAL FIX: Apply message filtering to allRows before pagination
  const filteredRows = allRows.filter(messageFilter);
  
  const totalPages = Math.ceil(filteredRows.length / ITEMS_PER_PAGE);
  const startIndex = (page - 1) * ITEMS_PER_PAGE;
  const endIndex = startIndex + ITEMS_PER_PAGE;
  const rows = filteredRows.slice(startIndex, endIndex);
  
  // DEBUG: Log pagination calculation
  console.log(`ðŸ“„ Pagination debug:`, {
    currentTab,
    allRowsLength: allRows.length,
    filteredRowsLength: filteredRows.length,
    allLogsLength: allLogs.length,
    allFlagsLength: allFlags.length,
    page,
    totalPages,
    startIndex,
    endIndex,
    rowsLength: rows.length,
    ITEMS_PER_PAGE,
    groupFilter,
    senderFilter,
    search
  });

  const allGroups = [...new Set(allLogs.concat(allFlags).map(r => r.group_name).filter(Boolean))];
  const allSenders = [...new Set(allLogs.concat(allFlags).map(r => r.sender_name).filter(Boolean))];

  // CRITICAL FIX: Message filtering function - moved to main scope for accessibility
  const messageFilter = useCallback((row) => {
    if (groupFilter && row.group_name !== groupFilter) return false;
    if (senderFilter && row.sender_name !== senderFilter) return false;
    if (search && !row.message?.toLowerCase().includes(search.toLowerCase())) return false;
    
    // No date filtering - show all messages in real-time order
    return true;
  }, [groupFilter, senderFilter, search]);

  // Real-time socket connection - FIXED: Make it persistent and more stable
  useEffect(() => {
    if (!realtime) return;
    
    // CRITICAL FIX: Always maintain WebSocket connection regardless of date range
    // This ensures real-time updates work consistently
    console.log('ðŸ”Œ Establishing persistent WebSocket connection...');
    
    const socket = io(SOCKET_URL, { 
      transports: ["websocket"],
      timeout: 20000,
      forceNew: false,
      reconnection: true,
      reconnectionDelay: 1000,
      reconnectionAttempts: 5,
      maxReconnectionAttempts: 10
    });

    // ENHANCED: Comprehensive connection management
    socket.on('connect', () => {
      console.log('âœ… WebSocket connected - Real-time updates active');
      logInfo('WebSocket', 'Connected to server', { 
        url: SOCKET_URL,
        timestamp: new Date().toISOString()
      });
      setConnectionStatus('connected');
      // Re-sync data after reconnection
      if (wasDisconnected) {
        console.log('ðŸ”„ Re-syncing data after reconnection...');
        logInfo('WebSocket', 'Re-syncing data after reconnection');
        fetchData();
        setWasDisconnected(false);
      }
    });

    socket.on('disconnect', (reason) => {
      console.log('âŒ WebSocket disconnected:', reason);
      logWarn('WebSocket', 'Disconnected from server', { reason });
      setConnectionStatus('disconnected');
      setWasDisconnected(true);
    });

    socket.on('connect_error', (error) => {
      console.error('âŒ WebSocket connection error:', error);
      logError('WebSocket', 'Connection error', { error: error.message });
      setConnectionStatus('error');
    });

    socket.on('reconnect', (attemptNumber) => {
      console.log('ðŸ”„ WebSocket reconnected after', attemptNumber, 'attempts');
      setConnectionStatus('connected');
      setWasDisconnected(false);
    });

    socket.on('reconnect_attempt', (attemptNumber) => {
      console.log('ðŸ”„ WebSocket reconnection attempt:', attemptNumber);
      setConnectionStatus('reconnecting');
    });

    // Add ping/pong for connection quality monitoring
    const pingInterval = setInterval(() => {
      if (socket.connected) {
        const start = Date.now();
        socket.emit('ping', start);
        socket.once('pong', (timestamp) => {
          const latency = Date.now() - timestamp;
          setConnectionLatency(latency);
        });
      }
    }, 10000);

    socket.on("new_message", (row) => {
      console.log('ðŸ“¨ Received new message via WebSocket:', {
        id: row.id,
        sender: row.sender_name,
        timestamp: row.received_at,
        hasMedia: row.has_media
      });
      
      logInfo('WebSocket', 'Received new message', {
        id: row.id,
        sender: row.sender_name,
        timestamp: row.received_at,
        hasMedia: row.has_media,
        message: row.message?.substring(0, 100)
      });
      
      // CRITICAL FIX: Validate and provide fallback values for missing fields
      const validatedRow = {
        id: row.id || `temp_${Date.now()}_${Math.random()}`, // Ensure unique ID
        sender_name: row.sender_name || 'Unknown Sender',
        group_name: row.group_name || 'Direct Message',
        message: row.message || '[No Text]',
        received_at: row.received_at || new Date().toISOString(),
        number: row.number || 'Unknown',
        has_media: row.has_media || false,
        media_type: row.media_type || null,
        media_size: row.media_size || null,
        media_filename: row.media_filename || null,
        processing_status: row.processing_status || null,
        sentiment: row.sentiment || null,
        intent: row.intent || null,
        is_flagged: row.is_flagged || false,
        flag_type: row.flag_type || null,
        flag_reason: row.flag_reason || null,
        // Preserve any other fields that might exist
        ...row
      };
      
      console.log('âœ… Validated message with fallback values:', {
        id: validatedRow.id,
        sender: validatedRow.sender_name,
        message: validatedRow.message?.substring(0, 50)
      });
      
      // ENHANCED: Dispatch custom event for Header component
      window.dispatchEvent(new CustomEvent('websocket-message-received', {
        detail: { type: 'new_message', data: validatedRow }
      }));
      
      // CRITICAL FIX: Always add real-time messages to UI, regardless of date filters
      // Real-time messages should appear instantly - user can filter later if needed
      console.log('âœ… Adding real-time message to UI (no filtering)');
      
      setAllLogs((prev) => {
        // Avoid duplicates by checking ID (now guaranteed to exist)
        const exists = prev.some(msg => msg.id === validatedRow.id);
        if (exists) {
          console.log('âš ï¸ Message already exists, skipping duplicate');
          return prev;
        }
        const newAllLogs = [validatedRow, ...prev].slice(0, 500);
        console.log(`ðŸ“Š Updated allLogs: ${newAllLogs.length} messages total`);
        return newAllLogs;
      });
      
      // CRITICAL FIX: Always show real-time messages in UI (no date restrictions)
      setLogs((prev) => {
        // Avoid duplicates by checking ID (now guaranteed to exist)
        const exists = prev.some(msg => msg.id === validatedRow.id);
        if (exists) return prev;
        const newLogs = [validatedRow, ...prev].slice(0, ITEMS_PER_PAGE);
        console.log(`ðŸ“Š Updated logs: ${newLogs.length} messages in current view`);
        return newLogs;
      });
      
      // Also update infinite scroll data if active
      if (isInfiniteScroll) {
        setInfiniteScrollData((prev) => {
          const exists = prev.some(msg => msg.id === validatedRow.id);
          if (exists) return prev;
          const newInfiniteData = [validatedRow, ...prev];
          console.log(`ðŸ“Š Updated infiniteScrollData: ${newInfiniteData.length} messages`);
          return newInfiniteData;
        });
      }
      
      // Increment pending AI count for new message
      setPendingAICount(prev => prev + 1);

      // Add visual notification for real-time updates
      setNotification({
        open: true,
        message: `ðŸ“¨ New message from ${validatedRow.sender_name}`,
        type: 'message',
        count: 1
      });
    });

    socket.on("flagged_message", (row) => {
      console.log('ðŸš© Received flagged message via WebSocket:', {
        id: row.id,
        sender: row.sender_name,
        flagType: row.flag_type
      });
      
      // CRITICAL FIX: Validate and provide fallback values for missing fields
      const validatedRow = {
        id: row.id || `temp_${Date.now()}_${Math.random()}`, // Ensure unique ID
        sender_name: row.sender_name || 'Unknown Sender',
        group_name: row.group_name || 'Direct Message',
        message: row.message || '[No Text]',
        received_at: row.received_at || new Date().toISOString(),
        number: row.number || 'Unknown',
        has_media: row.has_media || false,
        media_type: row.media_type || null,
        media_size: row.media_size || null,
        media_filename: row.media_filename || null,
        processing_status: row.processing_status || null,
        sentiment: row.sentiment || null,
        intent: row.intent || null,
        is_flagged: true, // Always true for flagged messages
        flag_type: row.flag_type || 'manual',
        flag_reason: row.flag_reason || 'Flagged via WebSocket',
        // Preserve any other fields that might exist
        ...row
      };
      
      console.log('âœ… Validated flagged message with fallback values:', {
        id: validatedRow.id,
        sender: validatedRow.sender_name,
        message: validatedRow.message?.substring(0, 50)
      });
      
      // ENHANCED: Dispatch custom event for Header component
      window.dispatchEvent(new CustomEvent('websocket-message-received', {
        detail: { type: 'flagged_message', data: validatedRow }
      }));
      
      // CRITICAL FIX: Always add real-time flagged messages to UI, regardless of date filters
      console.log('âœ… Adding real-time flagged message to UI (no filtering)');
      
      setAllFlags((prev) => {
        const exists = prev.some(msg => msg.id === validatedRow.id);
        if (exists) return prev;
        return [validatedRow, ...prev].slice(0, 500);
      });
      
      // Always add to current flags (real-time always active)
      setFlags((prev) => {
        const exists = prev.some(msg => msg.id === validatedRow.id);
        if (exists) return prev;
        return [validatedRow, ...prev].slice(0, ITEMS_PER_PAGE);
      });
      
      // Also update infinite scroll data if active
      if (isInfiniteScroll) {
        setInfiniteScrollData((prev) => {
          const exists = prev.some(msg => msg.id === validatedRow.id);
          if (exists) return prev;
          return [validatedRow, ...prev];
        });
      }
      
      // Add visual notification for flagged messages
      setNotification({
        open: true,
        message: `ðŸš© Flagged message from ${validatedRow.sender_name}`,
        type: 'flagged',
        count: 1
      });
    });

    // ENHANCED: Listen for contextual AI analysis updates (background processing)
    socket.on("message_ai_update", (updateData) => {
      try {
        console.log('ðŸ§  AI Analysis Update:', updateData?.id);
        
        // CRITICAL: Add null checks and error handling
        if (!updateData?.id || !updateData?.ai_analysis) {
          console.warn('âš ï¸ Invalid AI update data:', updateData);
          return;
        }

        console.log('ðŸ§  Received contextual AI analysis update via WebSocket:', {
          id: updateData.id,
          ai_category: updateData.ai_analysis.ai_category,
          is_flagged: updateData.ai_analysis.is_flagged,
          urgency_level: updateData.ai_analysis.urgency_level,
          contextual_risk: updateData.ai_analysis.contextual_risk,
          confidence: updateData.ai_analysis.ai_confidence
        });
        
        // Update message with enhanced contextual AI analysis without component refresh
        const updateMessageWithAI = (prev) => prev.map(msg => 
          msg.id === updateData.id 
            ? {
                ...msg,
                // Legacy AI fields (sentiment/intent) with null checks
                sentiment: updateData.ai_analysis.sentiment || msg.sentiment,
                intent: updateData.ai_analysis.intent || msg.intent,
                entities: updateData.ai_analysis.entities || msg.entities,
                flag_reason: updateData.ai_analysis.ai_flag_reason || updateData.ai_analysis.flag_reason || msg.flag_reason,
                flag_type: updateData.ai_analysis.ai_category || updateData.ai_analysis.flag_type || msg.flag_type,
                confidence: updateData.ai_analysis.ai_confidence || updateData.ai_analysis.confidence || msg.confidence,
                is_flagged: updateData.ai_analysis.is_flagged !== undefined ? updateData.ai_analysis.is_flagged : msg.is_flagged,
                // NEW: Enhanced contextual AI fields with null checks
                ai_category: updateData.ai_analysis.ai_category || msg.ai_category,
                ai_flag_reason: updateData.ai_analysis.ai_flag_reason || msg.ai_flag_reason,
                ai_confidence: updateData.ai_analysis.ai_confidence || msg.ai_confidence,
                escalation_factors: updateData.ai_analysis.escalation_factors || msg.escalation_factors,
                instruction_type: updateData.ai_analysis.instruction_type || msg.instruction_type,
                urgency_level: updateData.ai_analysis.urgency_level || msg.urgency_level,
                contextual_risk: updateData.ai_analysis.contextual_risk || msg.contextual_risk,
                repetition_count: updateData.ai_analysis.repetition_count || msg.repetition_count,
                recommended_action: updateData.ai_analysis.recommended_action || msg.recommended_action,
                contextual_assessment: updateData.ai_analysis.contextual_assessment || msg.contextual_assessment,
                ai_source: updateData.ai_analysis.ai_source || msg.ai_source,
                // Mark as AI processed with timestamp
                ai_processed: true,
                ai_processed_at: new Date().toISOString()
              }
            : msg
        );
        
        // Update all message states atomically
        setAllLogs(updateMessageWithAI);
        setLogs(updateMessageWithAI);
        
        if (isInfiniteScroll) {
          setInfiniteScrollData(updateMessageWithAI);
        }

        // Decrease pending AI count
        setPendingAICount(prev => Math.max(0, prev - 1));
        
        // Show contextual AI analysis notification for flagged messages
        if (updateData.ai_analysis.is_flagged) {
          setNotification({
            open: true,
            message: `ðŸ¤– AI flagged message: ${updateData.ai_analysis.ai_category || updateData.ai_analysis.flag_type}`,
            type: 'ai_flagged',
            count: 1
          });
        }
        
      } catch (error) {
        console.error('âŒ AI update error:', error);
        // Don't let AI errors crash real-time system
        setPendingAICount(prev => Math.max(0, prev - 1));
      }
    });

    // ENHANCED: Listen for media processing completion updates
    socket.on("media_updated", (mediaData) => {
      console.log('ðŸ“¸ Received media update via WebSocket:', {
        id: mediaData.id,
        filename: mediaData.media_filename,
        size: mediaData.media_size,
        type: mediaData.media_type
      });
      
      // Update all message states with the new media metadata
      const updateMessage = (prev) => prev.map(msg => 
        msg.id === mediaData.id 
          ? {
              ...msg,
              media_filename: mediaData.media_filename,
              media_size: mediaData.media_size,
              media_mime_type: mediaData.media_mime_type,
              processing_status: mediaData.processing_status
            }
          : msg
      );
      
      setAllLogs(updateMessage);
      setLogs(updateMessage);
      setAllFlags(updateMessage);
      setFlags(updateMessage);
      
      if (isInfiniteScroll) {
        setInfiniteScrollData(updateMessage);
      }
      
      // Show notification that media is ready
      setNotification({
        open: true,
        message: `ðŸ“¸ Media ready for message from ${mediaData.sender_name}`,
        type: 'media_ready',
        count: 1
      });
    });

    // ENHANCED: Expose socket for monitoring in Header component
    window.WebSocketMonitor = { socket };

    return () => {
      console.log('ðŸ”Œ Disconnecting WebSocket...');
      clearInterval(pingInterval);
      window.WebSocketMonitor = null;
      socket.disconnect();
    };
  }, [realtime]); // CRITICAL FIX: Only depend on realtime toggle, not filters

  // Enhanced data fetching with pagination and date filtering
  const fetchData = useCallback(async (loadMore = false, customPage = null) => {
    logInfo('API', 'Fetching data', {
      loadMore,
      customPage,
      currentTab,
      groupFilter,
      senderFilter,
      search
    });
    
    if (loadMore) {
      setLoadingMore(true);
    } else {
      setLoading(true);
    }
    
    try {
      let url = currentTab === "logs" ? "/api/logs" : "/api/flags";
      let params = [];
      
      // Add pagination parameters
      const currentPage = customPage || page;
      params.push(`page=${currentPage}`);
      params.push(`limit=${ITEMS_PER_PAGE}`);
      
      // No date filtering - show all messages in real-time order
      
      // Add filter parameters
      if (groupFilter) params.push(`group=${encodeURIComponent(groupFilter)}`);
      if (senderFilter) params.push(`sender=${encodeURIComponent(senderFilter)}`);
      if (search) params.push(`q=${encodeURIComponent(search)}`);
      
      if (params.length) url += "?" + params.join("&");
      
      const res = await fetch(url);
      const data = await res.json();
      
      if (currentTab === "logs") {
        // For all messages, check which ones are flagged
        const flaggedRes = await fetch('/api/flags');
        const flaggedData = await flaggedRes.json();
        
        // Create a map of flagged messages by message content and sender
        const flaggedMap = new Map();
        (flaggedData.messages || flaggedData).forEach(flag => {
          const key = `${flag.message}_${flag.sender_name}_${flag.group_name || ''}`;
          flaggedMap.set(key, flag);
        });
        
        // Add flagged status to all messages
        const enrichedData = (data.messages || data).map(msg => {
          const key = `${msg.message}_${msg.sender_name}_${msg.group_name || ''}`;
          const flaggedInfo = flaggedMap.get(key);
          return {
            ...msg,
            is_flagged: !!flaggedInfo,
            flag_type: flaggedInfo?.flag_type || null,
            flag_reason: flaggedInfo?.flag_reason || null
          };
        });
        
        // Set total count
        setTotalMessages(data.total || enrichedData.length);
        
        if (loadMore && isInfiniteScroll) {
          // Infinite scroll: append new data
          setInfiniteScrollData(prev => [...prev, ...enrichedData]);
          setHasMoreData(enrichedData.length === ITEMS_PER_PAGE && infiniteScrollData.length + enrichedData.length < MAX_INFINITE_SCROLL_ITEMS);
          
          // Switch to pagination if we hit the limit
          if (infiniteScrollData.length + enrichedData.length >= MAX_INFINITE_SCROLL_ITEMS) {
            setIsInfiniteScroll(false);
            setAllLogs(enrichedData);
            setLogs(enrichedData);
          }
        } else {
          // Regular pagination or initial load
          setAllLogs(enrichedData);
          setLogs(enrichedData);
          
          if (isInfiniteScroll && !loadMore) {
            setInfiniteScrollData(enrichedData);
            setHasMoreData(enrichedData.length === ITEMS_PER_PAGE && enrichedData.length < MAX_INFINITE_SCROLL_ITEMS);
          }
        }
      } else {
        const enrichedFlags = data.messages || data;
        setTotalMessages(data.total || enrichedFlags.length);
        
        if (loadMore && isInfiniteScroll) {
          setInfiniteScrollData(prev => [...prev, ...enrichedFlags]);
          setHasMoreData(enrichedFlags.length === ITEMS_PER_PAGE && infiniteScrollData.length + enrichedFlags.length < MAX_INFINITE_SCROLL_ITEMS);
          
          if (infiniteScrollData.length + enrichedFlags.length >= MAX_INFINITE_SCROLL_ITEMS) {
            setIsInfiniteScroll(false);
            setAllFlags(enrichedFlags);
            setFlags(enrichedFlags);
          }
        } else {
          setAllFlags(enrichedFlags);
          setFlags(enrichedFlags);
          
          if (isInfiniteScroll && !loadMore) {
            setInfiniteScrollData(enrichedFlags);
            setHasMoreData(enrichedFlags.length === ITEMS_PER_PAGE && enrichedFlags.length < MAX_INFINITE_SCROLL_ITEMS);
          }
        }
      }
      
      if (!loadMore) {
        setPage(1); // Reset to first page on new search/filter
      }
    } catch (error) {
      setAlert("Error loading data!");
      console.error('Error fetching data:', error);
      logError('API', 'Error fetching data', { 
        error: error.message,
        loadMore,
        customPage,
        currentTab
      });
    }
    
    if (loadMore) {
      setLoadingMore(false);
    } else {
      setLoading(false);
    }
  }, [currentTab, groupFilter, senderFilter, search, page, isInfiniteScroll, infiniteScrollData.length]);

  // Load more data for infinite scroll
  const loadMoreData = useCallback(() => {
    if (!hasMoreData || loadingMore || !isInfiniteScroll) return;
    
    const nextPage = Math.floor(infiniteScrollData.length / ITEMS_PER_PAGE) + 1;
    fetchData(true, nextPage);
  }, [hasMoreData, loadingMore, isInfiniteScroll, infiniteScrollData.length, fetchData]);

  // Infinite scroll detection
  useEffect(() => {
    const handleScroll = () => {
      if (!isInfiniteScroll || loadingMore || !hasMoreData) return;
      
      const scrollPosition = window.scrollY + window.innerHeight;
      const documentHeight = document.documentElement.scrollHeight;
      
      // Load more when user is 200px from bottom
      if (scrollPosition >= documentHeight - 200) {
        loadMoreData();
      }
    };

    window.addEventListener('scroll', handleScroll);
    return () => window.removeEventListener('scroll', handleScroll);
  }, [isInfiniteScroll, loadMoreData, loadingMore, hasMoreData]);

  // Reset infinite scroll when filters change
  useEffect(() => {
    setIsInfiniteScroll(true);
    setInfiniteScrollData([]);
    setHasMoreData(true);
    setPage(1);
  }, [groupFilter, senderFilter, search]);

  // Trigger data fetching when dependencies change
  useEffect(() => { 
    fetchData(); 
  }, [fetchData]);
  
  // CRITICAL FIX: Update totalMessages when filters change to reflect filtered count
  useEffect(() => {
    const allRows = currentTab === "logs" ? allLogs : allFlags;
    const filteredRows = allRows.filter(messageFilter);
    setTotalMessages(filteredRows.length);
  }, [currentTab, allLogs, allFlags, messageFilter]);

  // WhatsApp status
  const fetchWaStatus = useCallback(async () => {
    try {
      const res = await fetch('/status');
      const html = await res.text();
      // Updated regex to handle HTML tags (both <strong> and **) and different formats
      const match = html.match(/(?:<strong>)?(?:\*\*)?WhatsApp State(?:\*\*)?(?:<\/strong>)?:\s*([^<]+)/);
      if (match) {
        const status = match[1].trim();
        setWaStatus(status);
        
        // Log status for debugging
        console.log('WhatsApp Status Update:', status);
        
        // Update connection state based on status
        if (status === 'CONNECTED') {
          // Status is connected, ensure UI reflects this
        } else if (status === 'WAITING FOR QR SCAN') {
          // QR scan required
        } else if (status === 'INITIALIZING') {
          // Service starting up
        }
      } else {
        // If regex fails, try to find the status in a different way
        console.log('Regex failed, trying alternative parsing...');
        const statusMatch = html.match(/<p><strong>WhatsApp State:<\/strong>\s*([^<]+)<\/p>/);
        if (statusMatch) {
          const status = statusMatch[1].trim();
          setWaStatus(status);
          console.log('WhatsApp Status Update (alternative):', status);
        } else {
          console.log('Could not parse WhatsApp status from HTML:', html.substring(0, 500));
          setWaStatus('Unknown');
        }
      }
    } catch (error) {
      console.error('Error fetching WhatsApp status:', error);
      setWaStatus('Unknown');
    }
  }, []);

  useEffect(() => {
    fetchWaStatus();
    const interval = setInterval(fetchWaStatus, 10000);
    return () => clearInterval(interval);
  }, [fetchWaStatus]);

  // Fetch keywords and analytics
  const fetchKeywords = useCallback(async () => {
    try {
      const [reviewRes, staticRes, analyticsRes] = await Promise.all([
        axios.get("/api/flag_keywords?status=pending"),
        axios.get("/api/static_flag_keywords"),
        axios.get("/api/keyword_analytics")
      ]);
      setKeywordReview(reviewRes.data);
      setStaticKeywords(staticRes.data);
      setKeywordAnalytics(analyticsRes.data);
    } catch (e) {
      console.error("Error fetching keywords:", e);
    }
  }, []);

  useEffect(() => { fetchKeywords(); }, [fetchKeywords]);

  const handleNavigation = (key) => {
    logInfo('Navigation', 'Navigating to view', { 
      from: currentView, 
      to: key 
    });
    navigate(`/${key}`);
    setCurrentView(key);
    if (key === "messages") {
      setCurrentTab("logs");
    } else if (key === "flagged") {
      setCurrentTab("flags");
    }
    if (isMobile) {
      setSidebarOpen(false);
    }
  };

  const handleTabChange = (_, newTab) => {
    setCurrentTab(newTab);
    setPage(1); // Reset pagination when switching tabs
  };

  const handlePageChange = (_, newPage) => {
    setPage(newPage);
    // Update displayed rows for current page
    const startIndex = (newPage - 1) * ITEMS_PER_PAGE;
    const endIndex = startIndex + ITEMS_PER_PAGE;
    if (currentTab === "logs") {
      setLogs(allLogs.slice(startIndex, endIndex));
    } else {
      setFlags(allFlags.slice(startIndex, endIndex));
    }
  };

  const handleKeywordAction = async (id, action) => {
    try {
      await axios.post(`/api/flag_keywords/${id}/${action}`);
      fetchKeywords();
    } catch (e) {
      setAlert(`Error ${action}ing keyword`);
    }
  };

  const getSentimentColor = (sentiment) => {
    switch (sentiment?.toLowerCase()) {
      case 'positive': return BRAND_COLORS.green;
      case 'negative': return BRAND_COLORS.red;
      default: return BRAND_COLORS.mediumGray;
    }
  };

  const getIntentColor = (intent) => {
    switch (intent?.toLowerCase()) {
      case 'complaint': return BRAND_COLORS.red;
      case 'question': return BRAND_COLORS.mediumGray;
      case 'booking': return BRAND_COLORS.green;
      default: return BRAND_COLORS.mediumGray;
    }
  };

  const formatTime = (timestamp) => {
    if (!timestamp) return "--";
    const date = new Date(timestamp);
    const now = new Date();
    const isToday = date.toDateString() === now.toDateString();
    
    if (isToday) {
      return date.toLocaleTimeString("en-US", { 
        hour: 'numeric',
        minute: '2-digit',
        hour12: true
      });
    } else {
      return date.toLocaleDateString("en-US", { 
        month: 'short',
        day: 'numeric',
        hour: 'numeric',
        minute: '2-digit',
        hour12: true
      });
    }
  };

  const closeSidebar = () => {
    if (isMobile || !sidebarOpen) return;
    setSidebarOpen(false);
  };

  // Interactive handlers
  const handleMessageClick = (message) => {
    setSelectedMessage(message);
    setMessageDetailOpen(true);
  };

  const handleBadgeClick = (type, value) => {
    // Apply filter based on badge click
    if (type === 'sentiment') {
      // Filter by sentiment - this would need backend support
      setAlert(`Filtering by sentiment: ${value}`);
    } else if (type === 'intent') {
      // Filter by intent
      setAlert(`Filtering by intent: ${value}`);
    } else if (type === 'flag_type') {
      // Filter by flag type
      setAlert(`Filtering by flag type: ${value}`);
    }
    // Refresh data with new filters
    fetchData();
  };

  const handleAnalyticsClick = (title, metricType, value) => {
    setAnalyticsModal({
      open: true,
      title,
      metricType,
      value
    });
  };

  const handleConfirmAction = (action, data, options = {}) => {
    setConfirmationModal({
      open: true,
      action,
      data,
      ...options
    });
  };

  const executeAction = async () => {
    setActionLoading(true);
    try {
      const { action, data } = confirmationModal;
      
      switch (action) {
        case 'approve_keyword':
          await axios.post(`/api/flag_keywords/${data.id}/approve`);
          fetchKeywords();
          setAlert('Keyword approved successfully');
          break;
        case 'reject_keyword':
          await axios.post(`/api/flag_keywords/${data.id}/reject`);
          fetchKeywords();
          setAlert('Keyword rejected successfully');
          break;
        case 'delete_keyword':
          await axios.delete(`/api/static_flag_keywords/${data.id}`);
          fetchKeywords();
          setAlert('Keyword deleted successfully');
          break;
        case 'escalate_message':
          await axios.post(`/api/messages/${data.id}/escalate`, {
            escalationReason: 'Manual escalation via dashboard',
            priority: 'high'
          });
          fetchData();
          setAlert('ðŸš¨ Message escalated successfully! Management has been notified via WhatsApp and Slack.');
          break;
        default:
          setAlert('Unknown action');
      }
      
      setConfirmationModal({ open: false, action: null, data: null });
    } catch (error) {
      console.error('Action execution error:', error);
      setAlert(`Error executing action: ${error.response?.data?.error || error.message}`);
    } finally {
      setActionLoading(false);
    }
  };

  const handleFilterChange = (filterType, value) => {
    logInfo('Filter', 'Filter changed', { 
      filterType, 
      value,
      currentTab 
    });
    
    // Dynamic filter updates with immediate effect
    switch (filterType) {
      case 'group':
        setGroupFilter(value);
        break;
      case 'sender':
        setSenderFilter(value);
        break;
      case 'search':
        setSearch(value);
        break;
    }
    setPage(1); // Reset to first page
  };

  const toggleSidebar = () => {
    setSidebarOpen(!sidebarOpen);
  };

  const toggleSidebarCollapse = () => {
    setSidebarCollapsed(!sidebarCollapsed);
  };

  const toggleFilters = () => {
    setFiltersOpen(!filtersOpen);
  };

  const clearFilters = () => {
    setGroupFilter("");
    setSenderFilter("");
    setSearch("");
    setFiltersOpen(false);
  };

  const handleFlagMessage = async (message) => {
    try {
      await axios.post(`/api/messages/${message.id}/flag`);
      setAlert('Message flagged successfully');
      fetchData();
    } catch (error) {
      setAlert('Error flagging message');
    }
  };

  const handleUnflagMessage = async (message) => {
    try {
      await axios.post(`/api/messages/${message.id}/unflag`);
      setAlert('Message unflagged successfully');
      fetchData();
    } catch (error) {
      setAlert('Error unflagging message');
    }
  };

  const handleEscalateMessage = async (message) => {
    // Enhanced escalation workflow with multiple options
    const escalationOptions = {
      title: 'ðŸš¨ Escalate Message to Management',
      message: `Are you sure you want to escalate this message? This will trigger immediate alerts to management and create a high-priority issue.`,
      confirmText: 'Escalate Now',
      severity: 'warning',
      details: `Message: "${message.message}" from ${message.sender_name || 'Unknown'} in ${message.group_name || 'Direct Message'}`,
      showUndo: false,
      additionalInfo: {
        escalationLevels: [
          { level: 'medium', description: 'Standard escalation - 4 hour response time' },
          { level: 'high', description: 'Urgent escalation - 2 hour response time' },
          { level: 'critical', description: 'Emergency escalation - 30 minute response time' }
        ],
        consequences: [
          'ðŸ“± WhatsApp alerts sent to management groups',
          'ðŸ“§ Slack notifications to all stakeholders', 
          'ðŸŽ¯ Issue marked as high priority in system',
          'â° Response timer starts immediately',
          'ðŸ“Š Escalation tracked in analytics dashboard'
        ]
      }
    };

    handleConfirmAction('escalate_message', message, escalationOptions);
  };

  const handleMessageAction = async (action, message) => {
    logInfo('MessageAction', 'Performing message action', { 
      action, 
      messageId: message.id,
      sender: message.sender_name 
    });
    
    try {
      switch (action) {
        case 'flag':
          await executeAction('flag_message', message);
          break;
        case 'escalate':
          await executeAction('escalate_message', message);
          break;
        case 'unflag':
          await executeAction('unflag_message', message);
          break;
      }
      setMessageDetailOpen(false);
      // Refresh data
      fetchData();
    } catch (error) {
      console.error('Action failed:', error);
      logError('MessageAction', 'Action failed', { 
        action, 
        messageId: message.id,
        error: error.message 
      });
    }
  };

  // Auto-save memory function
  const savePageMemory = useCallback(async (previousView, newView) => {
    try {
      const sessionId = sessionStorage.getItem('dashboard_session_id') || 
                       `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      
      if (!sessionStorage.getItem('dashboard_session_id')) {
        sessionStorage.setItem('dashboard_session_id', sessionId);
      }

      const memoryData = {
        session_id: sessionId,
        page_data: {
          previous_page: previousView,
          current_page: newView,
          navigation_method: 'route_change',
          url_pathname: location.pathname,
          url_search: location.search,
          timestamp: new Date().toISOString(),
          dashboard_state: {
            sidebar_open: sidebarOpen,
            sidebar_collapsed: sidebarCollapsed,
            current_tab: currentTab,
            filters: {
              group: groupFilter,
              sender: senderFilter,
              search: search
            },
            pagination: {
              current_page: page,
              total_messages: allLogs.length,
              total_flags: allFlags.length
            }
          }
        },
        user_context: {
          whatsapp_status: waStatus,
          realtime_enabled: realtime,
          message_count: allLogs.length + allFlags.length,
          is_mobile: isMobile,
          loading_state: loading,
          browser_info: {
            user_agent: navigator.userAgent,
            viewport: {
              width: window.innerWidth,
              height: window.innerHeight
            },
            url: window.location.href
          }
        },
        memory_type: 'page_visit',
        description: `Page navigation from ${previousView || 'unknown'} to ${newView}`,
        auto_generated: true
      };

      const response = await fetch('/api/memory/save', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(memoryData)
      });

      if (response.ok) {
        console.log(`ðŸ“ Auto-saved memory for page transition: ${previousView} â†’ ${newView}`);
      }
    } catch (error) {
      console.warn('âš ï¸ Failed to save page memory:', error);
    }
  }, [sidebarOpen, sidebarCollapsed, currentTab, groupFilter, senderFilter, search, page, allLogs.length, allFlags.length, waStatus, realtime, isMobile, loading, location.pathname, location.search]);

  // Update currentView when route changes and auto-save memory
  useEffect(() => {
    const newView = getCurrentView();
    const previousView = currentView;
    setCurrentView(newView);
    
    // Set appropriate tab based on route
    if (newView === "messages") {
      setCurrentTab("logs");
    } else if (newView === "flagged") {
      setCurrentTab("flags");
    }

    // Auto-save memory when navigating to a new page (but not on initial load)
    if (previousView && previousView !== newView) {
      savePageMemory(previousView, newView);
    }
  }, [location.pathname, currentView, savePageMemory]);

  return (
    <UserInteractionLogger>
      <ThemeProvider theme={theme}>
        <CssBaseline />
        <Box sx={{ display: 'flex', flexDirection: 'column', minHeight: '100vh' }}>
        {/* Collapsible Sidebar */}
        <Sidebar
          open={sidebarOpen}
          collapsed={sidebarCollapsed}
          onClose={() => setSidebarOpen(false)}
          onToggleCollapse={toggleSidebarCollapse}
          navItems={NAV_ITEMS}
          currentView={currentView}
          onNavigation={handleNavigation}
          isMobile={isMobile}
        />

        {/* Top Header */}
        <Header
          sidebarOpen={sidebarOpen}
          onSidebarToggle={toggleSidebar}
          currentView={currentView}
          navItems={NAV_ITEMS}
          waStatus={waStatus}
          realtime={realtime}
          onRealtimeToggle={setRealtime}
          messageCount={allLogs.length + allFlags.length}
          isMobile={isMobile}
          isLoading={loading}
        />

        {/* Main Content with Routes */}
        <Box
          sx={{
            flex: 1,
            minHeight: '100vh',
            ml: getMainContentMargin(),
            transition: 'margin-left 0.3s cubic-bezier(0.4, 0, 0.2, 1)',
            background: BRAND_COLORS.lightGray,
            display: 'flex',
            flexDirection: 'column',
            position: 'relative',
            width: `calc(100vw - ${getMainContentMargin()}px)`
          }}
        >
          <Routes>
            <Route path="/" element={<MessagesView />} />
            <Route path="/messages" element={<MessagesView />} />
            <Route path="/flagged" element={<FlaggedView />} />
            <Route path="/analytics" element={<AnalyticsPage />} />
            <Route path="/ai_dashboard" element={<AIDashboardPage />} />
            <Route path="/ai_intelligence" element={<AIIntelligencePage />} />
            <Route path="/ai_labeling" element={<ManualLabelingPage />} />
            <Route path="/auto_healer" element={<AutoHealerPage />} />
            <Route path="/slack" element={<SlackIntegrationPage />} />
            <Route path="/digest" element={<DigestPage />} />
            <Route path="/keyword_analytics" element={<KeywordAnalyticsPage />} />
            <Route path="/flag_keywords" element={<FlagKeywordsPage />} />
            <Route path="/keyword_review" element={<KeywordReviewPage />} />
            <Route path="/issue_management" element={<IssueCategoriesPage />} />
            <Route path="/interaction_logs" element={<UserInteractionLogsPage />} />
            <Route path="/log-viewer" element={<LogViewerPage />} />
            <Route path="/health_monitor" element={<DashboardHealthMonitor />} />
            <Route path="/dashboard" element={<DashboardView />} />
            <Route path="/status" element={<StatusView />} />
            <Route path="/qr" element={<QRView />} />
            <Route path="/about" element={<AboutView />} />
            <Route path="/whatsapp_routing" element={<WhatsAppRoutingPage />} />
            <Route path="/ai_confidence" element={<AIConfidenceManagement />} />
            <Route path="/dynamic_categories" element={<DynamicCategoriesPage />} />
            <Route path="/endpoints" element={<EndpointsPage />} />
                      <Route path="/comprehensive_analytics" element={<ComprehensiveAnalyticsDashboard />} />
</Routes>
        </Box>

        {/* Filters Panel */}
        <FiltersPanel
          open={filtersOpen}
          onClose={() => setFiltersOpen(false)}
          groupFilter={groupFilter}
          senderFilter={senderFilter}
          search={search}
          onGroupFilterChange={setGroupFilter}
          onSenderFilterChange={setSenderFilter}
          onSearchChange={setSearch}
          onClearFilters={clearFilters}
          allGroups={allGroups}
          allSenders={allSenders}
          loading={loading}
        />

        {/* Notification Toast */}
        <NotificationToast
          open={notification.open}
          onClose={() => setNotification({ ...notification, open: false })}
          message={notification.message}
          type={notification.type}
          count={notification.count}
          severity="info"
        />

        {/* Enhanced Message Detail Modal */}
        <MessageDetailModal
          open={messageDetailOpen}
          onClose={() => setMessageDetailOpen(false)}
          message={selectedMessage}
          onAction={handleMessageAction}
        />

        <ConfirmationModal
          open={confirmationModal.open}
          onClose={() => setConfirmationModal({ open: false, action: null, data: null })}
          onConfirm={executeAction}
          title={confirmationModal.title || 'Confirm Action'}
          message={confirmationModal.message || 'Are you sure you want to proceed?'}
          confirmText={confirmationModal.confirmText || 'Confirm'}
          cancelText={confirmationModal.cancelText || 'Cancel'}
          severity={confirmationModal.severity || 'info'}
          loading={actionLoading}
          details={confirmationModal.details}
          showUndo={confirmationModal.showUndo}
        />

        <AnalyticsModal
          open={analyticsModal.open}
          onClose={() => setAnalyticsModal({ open: false, title: '', metricType: '', value: 0 })}
          title={analyticsModal.title}
          metricType={analyticsModal.metricType}
          initialValue={analyticsModal.value}
          onMessageClick={handleMessageClick}
          loading={loading}
        />

        {/* Real-time Status Indicator */}
        <Box sx={{
          position: 'fixed',
          top: 20,
          right: 20,
          zIndex: 9999,
          backgroundColor: connectionStatus === 'connected' ? '#10B981' : 
                          connectionStatus === 'reconnecting' ? '#F59E0B' : '#EF4444',
          color: 'white',
          padding: '8px 16px',
          borderRadius: '20px',
          fontSize: '12px',
          fontWeight: 'bold',
          display: 'flex',
          alignItems: 'center',
          gap: 1,
          boxShadow: '0 4px 12px rgba(0,0,0,0.15)',
          transition: 'all 0.3s ease'
        }}>
          <Box sx={{
            width: 8,
            height: 8,
            borderRadius: '50%',
            backgroundColor: 'white',
            animation: connectionStatus === 'connected' 
              ? 'pulse 2s infinite' 
              : connectionStatus === 'reconnecting'
              ? 'bounce 1.5s infinite'
              : 'none'
          }} />
          {connectionStatus === 'connected' ? 'Live' : 
           connectionStatus === 'reconnecting' ? 'Reconnecting...' : 
           connectionStatus === 'error' ? 'Error' : 'Disconnected'}
          {connectionStatus === 'connected' && connectionLatency > 0 && (
            <Typography sx={{ fontSize: '10px', opacity: 0.8 }}>
              {connectionLatency}ms
            </Typography>
          )}
          {pendingAICount > 0 && (
            <Chip 
              label={`ðŸ§  ${pendingAICount}`}
              size="small"
              sx={{ 
                ml: 1, 
                backgroundColor: 'rgba(255,255,255,0.2)', 
                color: 'white',
                fontSize: '10px',
                height: '20px'
              }}
            />
          )}
        </Box>

        {/* Alerts */}
        <Snackbar
          open={!!alert}
          autoHideDuration={3500}
          onClose={() => setAlert("")}
          message={alert}
        />
        
        {/* Live Console for Development */}
        <LiveConsole />
      </Box>
    </ThemeProvider>
    </UserInteractionLogger>
  );

  // Component definitions for each route
  function MessagesView() {
    // CRITICAL FIX: Ensure we always have data to display
    // If infinite scroll is active but has no data, fall back to logs
    // If logs is empty but allLogs has data, use allLogs
    let displayData = isInfiniteScroll ? infiniteScrollData : rows;
    let totalDisplayed = isInfiniteScroll ? infiniteScrollData.length : rows.length;
    
    // Fallback logic to ensure messages are always visible
    if (displayData.length === 0) {
      if (isInfiniteScroll && logs.length > 0) {
        console.log('ðŸ”„ Fallback: Using logs instead of empty infiniteScrollData');
        displayData = logs;
        totalDisplayed = logs.length;
      } else if (allLogs.length > 0) {
        console.log('ðŸ”„ Fallback: Using allLogs instead of empty displayData');
        displayData = allLogs.slice(0, ITEMS_PER_PAGE);
        totalDisplayed = displayData.length;
      }
    }
    
    // DEBUG: Log the data being rendered
    console.log(`ðŸ” MessagesView render:`, {
      displayDataLength: displayData.length,
      totalDisplayed,
      totalMessages,
      isInfiniteScroll,
      infiniteScrollDataLength: infiniteScrollData.length,
      rowsLength: rows.length,
      allLogsLength: allLogs.length,
      logsLength: logs.length,
      displayDataFirstItem: displayData[0] ? { id: displayData[0].id, sender: displayData[0].sender_name, message: displayData[0].message?.substring(0, 50) } : null
    });
    
    // Real-time is always active - no date restrictions
    const isRealTimeActive = realtime;
    
    return (
      <Box sx={{ height: '100%', display: 'flex', flexDirection: 'column' }}>
        {/* Header with filters */}
        <Box sx={{ 
          p: 3, 
          backgroundColor: BRAND_COLORS.white, 
          borderBottom: `1px solid ${BRAND_COLORS.border}`,
          position: 'sticky',
          top: 0,
          zIndex: 10
        }}>
          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 3 }}>
            <Box>
              <Typography variant="h5" sx={{ fontWeight: 700, color: BRAND_COLORS.darkGray }}>
                All Messages
              </Typography>
              <Typography variant="body2" sx={{ color: BRAND_COLORS.mediumGray, mt: 0.5 }}>
                {isInfiniteScroll 
                  ? `Showing ${totalDisplayed} of ${totalMessages} messages (Infinite Scroll ${totalDisplayed >= MAX_INFINITE_SCROLL_ITEMS ? '- Switched to Pagination' : ''})`
                  : `Showing ${totalDisplayed} of ${totalMessages} messages (Page ${page})`
                }
              </Typography>
            </Box>
            <Box sx={{ display: 'flex', gap: 2 }}>
              {isInfiniteScroll && totalDisplayed >= MAX_INFINITE_SCROLL_ITEMS && (
                <Button
                  variant="outlined"
                  onClick={() => {
                    setIsInfiniteScroll(false);
                    setPage(1);
                    fetchData();
                  }}
                  sx={{ color: BRAND_COLORS.darkGray, borderColor: BRAND_COLORS.border }}
                >
                  Switch to Pagination
                </Button>
              )}
              <Button
                variant="outlined"
                startIcon={<FilterListIcon />}
                onClick={toggleFilters}
                sx={{ color: BRAND_COLORS.darkGray, borderColor: BRAND_COLORS.border }}
              >
                Filters
              </Button>
              <Button
                variant="outlined"
                startIcon={<RefreshIcon />}
                onClick={() => fetchData()}
                disabled={loading}
                sx={{ color: BRAND_COLORS.darkGray, borderColor: BRAND_COLORS.border }}
              >
                Refresh
              </Button>
            </Box>
          </Box>

          {/* Real-time Status Indicator */}
          <Box sx={{ display: 'flex', gap: 2, alignItems: 'center', flexWrap: 'wrap', mb: 2 }}>
            <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, px: 2, py: 1, backgroundColor: BRAND_COLORS.green, borderRadius: 1 }}>
              {isRealTimeActive && (
                <Box
                  sx={{
                    width: 8,
                    height: 8,
                    borderRadius: '50%',
                    backgroundColor: BRAND_COLORS.white,
                    animation: 'pulse 2s infinite',
                    '@keyframes pulse': {
                      '0%': { opacity: 1 },
                      '50%': { opacity: 0.5 },
                      '100%': { opacity: 1 }
                    }
                  }}
                />
              )}
              <Typography variant="body2" sx={{ color: BRAND_COLORS.white, fontWeight: 'bold' }}>
                Real-time Stream {isRealTimeActive && 'â€¢ Live'}
              </Typography>
            </Box>
          </Box>

          {/* Filter Bar */}
          <Box sx={{ display: 'flex', gap: 2, alignItems: 'center', flexWrap: 'wrap' }}>
            <FormControl size="small" sx={{ minWidth: 120 }}>
              <Select
                value={groupFilter}
                onChange={(e) => setGroupFilter(e.target.value)}
                displayEmpty
                sx={{ backgroundColor: BRAND_COLORS.white }}
              >
                <MenuItem value="">All Groups</MenuItem>
                {allGroups.map(group => (
                  <MenuItem key={group} value={group}>{group}</MenuItem>
                ))}
              </Select>
            </FormControl>
            
            <FormControl size="small" sx={{ minWidth: 120 }}>
              <Select
                value={senderFilter}
                onChange={(e) => setSenderFilter(e.target.value)}
                displayEmpty
                sx={{ backgroundColor: BRAND_COLORS.white }}
              >
                <MenuItem value="">All Senders</MenuItem>
                {allSenders.map(sender => (
                  <MenuItem key={sender} value={sender}>{sender}</MenuItem>
                ))}
              </Select>
            </FormControl>
            
            <Box sx={{ display: 'flex', alignItems: 'center', backgroundColor: BRAND_COLORS.white, borderRadius: 1, px: 2, py: 1, border: `1px solid ${BRAND_COLORS.border}` }}>
              <SearchIcon sx={{ color: BRAND_COLORS.mediumGray, mr: 1 }} />
              <InputBase
                placeholder="Search messages..."
                value={search}
                onChange={(e) => setSearch(e.target.value)}
                sx={{ flex: 1, fontSize: '0.9rem' }}
              />
            </Box>
            
            {/* Clear Filters Button */}
            <Button
              size="small"
              variant="outlined"
              onClick={() => {
                setGroupFilter('');
                setSenderFilter('');
                setSearch('');
                // No date range to reset - removed date functionality
              }}
              sx={{ color: BRAND_COLORS.mediumGray, borderColor: BRAND_COLORS.border }}
            >
              Clear All
            </Button>
          </Box>
        </Box>

        {/* Messages Table */}
        <Box sx={{ flex: 1, overflow: 'auto', p: 3 }}>
          <StyledCard>
            <Table>
              <TableHead>
                <TableRow>
                  <TableCell sx={{ fontWeight: 600, color: BRAND_COLORS.darkGray, backgroundColor: BRAND_COLORS.lightGray, width: '120px' }}>Time</TableCell>
                  <TableCell sx={{ fontWeight: 600, color: BRAND_COLORS.darkGray, backgroundColor: BRAND_COLORS.lightGray, width: '150px' }}>Group</TableCell>
                  <TableCell sx={{ fontWeight: 600, color: BRAND_COLORS.darkGray, backgroundColor: BRAND_COLORS.lightGray, width: '150px' }}>Sender</TableCell>
                  <TableCell sx={{ fontWeight: 600, color: BRAND_COLORS.darkGray, backgroundColor: BRAND_COLORS.lightGray }}>Message</TableCell>
                  <TableCell sx={{ fontWeight: 600, color: BRAND_COLORS.darkGray, backgroundColor: BRAND_COLORS.lightGray, width: '100px' }}>Flagged</TableCell>
                  <TableCell sx={{ fontWeight: 600, color: BRAND_COLORS.darkGray, backgroundColor: BRAND_COLORS.lightGray, width: '120px' }}>Actions</TableCell>
                </TableRow>
              </TableHead>
              <TableBody>
                {loading ? (
                  Array.from({ length: 10 }).map((_, index) => (
                    <TableRow key={index}>
                      {Array.from({ length: 6 }).map((_, cellIndex) => (
                        <TableCell key={cellIndex}>
                          <Box sx={{ width: '100%', height: 20, backgroundColor: BRAND_COLORS.lightGray, borderRadius: 1, animation: 'pulse 1.5s ease-in-out infinite' }} />
                        </TableCell>
                      ))}
                    </TableRow>
                  ))
                ) : displayData.length === 0 ? (
                  <TableRow>
                    <TableCell colSpan={6} sx={{ textAlign: "center", py: 8, color: BRAND_COLORS.mediumGray }}>
                      No messages found for the selected date range and filters.
                    </TableCell>
                  </TableRow>
                ) : (
                  displayData.map((row, index) => (
                    <MessageRow
                      key={`${row.id || index}-${row.received_at}`}
                      row={row}
                      onView={handleMessageClick}
                      onFlag={(msg) => handleMessageAction('flag', msg)}
                      onEscalate={(msg) => handleMessageAction('escalate', msg)}
                    />
                  ))
                )}
                
                {/* Infinite Scroll Loading Indicator */}
                {isInfiniteScroll && loadingMore && (
                  <TableRow>
                    <TableCell colSpan={6} sx={{ textAlign: "center", py: 4 }}>
                      <Box sx={{ display: 'flex', flexDirection: 'column', alignItems: 'center', gap: 2 }}>
                        <CircularProgress size={24} />
                        <Typography variant="body2" color="text.secondary">
                          Loading more messages...
                        </Typography>
                      </Box>
                    </TableCell>
                  </TableRow>
                )}
                
                {/* End of Infinite Scroll Indicator */}
                {isInfiniteScroll && !hasMoreData && displayData.length > 0 && (
                  <TableRow>
                    <TableCell colSpan={6} sx={{ textAlign: "center", py: 4 }}>
                      <Typography variant="body2" color="text.secondary">
                        {displayData.length >= MAX_INFINITE_SCROLL_ITEMS 
                          ? `Reached maximum ${MAX_INFINITE_SCROLL_ITEMS} messages. Switch to pagination to see more.`
                          : 'No more messages to load.'
                        }
                      </Typography>
                    </TableCell>
                  </TableRow>
                )}
              </TableBody>
            </Table>
          </StyledCard>

          {/* Traditional Pagination (when not in infinite scroll mode) */}
          {!isInfiniteScroll && totalMessages > ITEMS_PER_PAGE && (
            <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mt: 3 }}>
              <Typography variant="body2" color="text.secondary">
                Showing {((page - 1) * ITEMS_PER_PAGE) + 1} to {Math.min(page * ITEMS_PER_PAGE, totalMessages)} of {totalMessages} messages
              </Typography>
              <Pagination
                count={Math.ceil(totalMessages / ITEMS_PER_PAGE)}
                page={page}
                onChange={handlePageChange}
                color="primary"
                size="large"
                showFirstButton
                showLastButton
              />
            </Box>
          )}
          
          {/* Infinite Scroll Instructions */}
          {isInfiniteScroll && displayData.length > 0 && hasMoreData && (
            <Box sx={{ textAlign: 'center', mt: 3, p: 2, backgroundColor: BRAND_COLORS.lightGray, borderRadius: 2 }}>
              <Typography variant="body2" color="text.secondary">
                ðŸ“œ Scroll down to load more messages automatically (up to {MAX_INFINITE_SCROLL_ITEMS} total)
              </Typography>
            </Box>
          )}
        </Box>
      </Box>
    );
  }

  function FlaggedView() {
    return (
      <Box sx={{ height: '100%', display: 'flex', flexDirection: 'column' }}>
        {/* Header with filters */}
        <Box sx={{ 
          p: 3, 
          backgroundColor: BRAND_COLORS.white, 
          borderBottom: `1px solid ${BRAND_COLORS.border}`,
          position: 'sticky',
          top: 0,
          zIndex: 10
        }}>
          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 3 }}>
            <Typography variant="h5" sx={{ fontWeight: 700, color: BRAND_COLORS.darkGray }}>
              Flagged Messages
            </Typography>
            <Box sx={{ display: 'flex', gap: 2 }}>
              <Button
                variant="outlined"
                startIcon={<FilterListIcon />}
                onClick={toggleFilters}
                sx={{ color: BRAND_COLORS.darkGray, borderColor: BRAND_COLORS.border }}
              >
                Filters
              </Button>
              <Button
                variant="outlined"
                startIcon={<RefreshIcon />}
                onClick={fetchData}
                disabled={loading}
                sx={{ color: BRAND_COLORS.darkGray, borderColor: BRAND_COLORS.border }}
              >
                Refresh
              </Button>
            </Box>
          </Box>

          {/* Filter Bar */}
          <Box sx={{ display: 'flex', gap: 2, alignItems: 'center', flexWrap: 'wrap' }}>
            <FormControl size="small" sx={{ minWidth: 120 }}>
              <Select
                value={groupFilter}
                onChange={(e) => setGroupFilter(e.target.value)}
                displayEmpty
                sx={{ backgroundColor: BRAND_COLORS.white }}
              >
                <MenuItem value="">All Groups</MenuItem>
                {allGroups.map(group => (
                  <MenuItem key={group} value={group}>{group}</MenuItem>
                ))}
              </Select>
            </FormControl>
            
            <FormControl size="small" sx={{ minWidth: 120 }}>
              <Select
                value={senderFilter}
                onChange={(e) => setSenderFilter(e.target.value)}
                displayEmpty
                sx={{ backgroundColor: BRAND_COLORS.white }}
              >
                <MenuItem value="">All Senders</MenuItem>
                {allSenders.map(sender => (
                  <MenuItem key={sender} value={sender}>{sender}</MenuItem>
                ))}
              </Select>
            </FormControl>
            
            <Box sx={{ display: 'flex', alignItems: 'center', backgroundColor: BRAND_COLORS.white, borderRadius: 1, px: 2, py: 1, border: `1px solid ${BRAND_COLORS.border}` }}>
              <SearchIcon sx={{ color: BRAND_COLORS.mediumGray, mr: 1 }} />
              <InputBase
                placeholder="Search flagged messages..."
                value={search}
                onChange={(e) => setSearch(e.target.value)}
                sx={{ flex: 1, fontSize: '0.9rem' }}
              />
            </Box>
          </Box>
        </Box>

        {/* Flagged Messages Table */}
        <Box sx={{ flex: 1, overflow: 'auto', p: 3 }}>
          <StyledCard>
            <Table>
              <TableHead>
                <TableRow>
                  <TableCell sx={{ fontWeight: 600, color: BRAND_COLORS.darkGray, backgroundColor: BRAND_COLORS.lightGray, width: '140px' }}>Time</TableCell>
                  <TableCell sx={{ fontWeight: 600, color: BRAND_COLORS.darkGray, backgroundColor: BRAND_COLORS.lightGray, width: '150px' }}>Group</TableCell>
                  <TableCell sx={{ fontWeight: 600, color: BRAND_COLORS.darkGray, backgroundColor: BRAND_COLORS.lightGray, width: '150px' }}>Sender</TableCell>
                  <TableCell sx={{ fontWeight: 600, color: BRAND_COLORS.darkGray, backgroundColor: BRAND_COLORS.lightGray, minWidth: '300px' }}>Message</TableCell>
                  <TableCell sx={{ fontWeight: 600, color: BRAND_COLORS.darkGray, backgroundColor: BRAND_COLORS.lightGray, width: '200px' }}>Sentiment</TableCell>
                  <TableCell sx={{ fontWeight: 600, color: BRAND_COLORS.darkGray, backgroundColor: BRAND_COLORS.lightGray, width: '200px' }}>Actions</TableCell>
                </TableRow>
              </TableHead>
              <TableBody>
                {loading ? (
                  Array.from({ length: 10 }).map((_, index) => (
                    <TableRow key={index}>
                      {Array.from({ length: 6 }).map((_, cellIndex) => (
                        <TableCell key={cellIndex}>
                          <Box sx={{ width: '100%', height: 20, backgroundColor: BRAND_COLORS.lightGray, borderRadius: 1, animation: 'pulse 1.5s ease-in-out infinite' }} />
                        </TableCell>
                      ))}
                    </TableRow>
                  ))
                ) : flags.length === 0 ? (
                  <TableRow>
                    <TableCell colSpan={6} sx={{ textAlign: "center", py: 8, color: BRAND_COLORS.mediumGray }}>
                      No flagged messages found.
                    </TableCell>
                  </TableRow>
                ) : (
                  flags.map((row, index) => (
                    <FlaggedMessageRow
                      key={index}
                      row={row}
                      onView={handleMessageClick}
                      onUnflag={(msg) => handleMessageAction('unflag', msg)}
                      onEscalate={(msg) => handleMessageAction('escalate', msg)}
                    />
                  ))
                )}
              </TableBody>
            </Table>
          </StyledCard>

          {/* Pagination */}
          {flags.length > ITEMS_PER_PAGE && (
            <Box sx={{ display: 'flex', justifyContent: 'center', mt: 3 }}>
              <Pagination
                count={totalPages}
                page={page}
                onChange={handlePageChange}
                color="primary"
                size="large"
              />
            </Box>
          )}
        </Box>
      </Box>
    );
  }

  function DashboardView() {
    return (
      <Box sx={{ p: 3 }}>
        <Paper sx={{ p: 4, textAlign: 'center', borderRadius: 2 }}>
          <Typography variant="h4" sx={{ mb: 2, color: BRAND_COLORS.darkGray }}>
            Welcome to WTF Intelligence Dashboard
          </Typography>
          <Typography variant="body1" sx={{ color: BRAND_COLORS.mediumGray, mb: 3 }}>
            Your comprehensive WhatsApp monitoring and analytics platform
          </Typography>
          <Box sx={{ display: 'flex', gap: 2, justifyContent: 'center', flexWrap: 'wrap' }}>
            <Button
              variant="contained"
              onClick={() => navigate('/messages')}
              sx={{ backgroundColor: BRAND_COLORS.red }}
            >
              View Messages
            </Button>
            <Button
              variant="outlined"
              onClick={() => navigate('/analytics')}
              sx={{ color: BRAND_COLORS.darkGray, borderColor: BRAND_COLORS.border }}
            >
              View Analytics
            </Button>
          </Box>
        </Paper>
      </Box>
    );
  }

  function StatusView() {
    const [statusData, setStatusData] = useState(null);
    const [healthData, setHealthData] = useState(null);
    const [loading, setLoading] = useState(true);
    const [clearingAuth, setClearingAuth] = useState(false);

    useEffect(() => {
      fetchStatusData();
      const interval = setInterval(fetchStatusData, 10000); // Refresh every 10 seconds
      return () => clearInterval(interval);
    }, []);

    const fetchStatusData = async () => {
      try {
        const [statusRes, healthRes] = await Promise.all([
          fetch('/status'),
          fetch('/api/health')
        ]);
        
        const statusText = await statusRes.text();
        const healthJson = await healthRes.json();
        
        setStatusData({ html: statusText, raw: statusText });
        setHealthData(healthJson);
      } catch (error) {
        console.error('Error fetching status:', error);
      } finally {
        setLoading(false);
      }
    };

    const handleClearAuth = async () => {
      setClearingAuth(true);
      try {
        const response = await fetch('/api/clear-whatsapp-auth', { method: 'POST' });
        const result = await response.json();
        
        if (result.success) {
          setAlert('WhatsApp authentication cleared successfully. Check /qr for new QR code.');
          setTimeout(fetchStatusData, 2000); // Refresh status after clearing
        } else {
          setAlert('Failed to clear authentication: ' + result.error);
        }
      } catch (error) {
        setAlert('Error clearing authentication: ' + error.message);
      } finally {
        setClearingAuth(false);
      }
    };

    if (loading) {
      return (
        <Box sx={{ p: 3, textAlign: 'center' }}>
          <CircularProgress sx={{ mb: 2 }} />
          <Typography>Loading system status...</Typography>
        </Box>
      );
    }

    return (
      <Box sx={{ p: 3 }}>
        <Typography variant="h4" sx={{ mb: 3, color: BRAND_COLORS.darkGray }}>
          System Status & Controls
        </Typography>
        
        <Grid container spacing={3}>
          {/* WhatsApp Status Card */}
          <Grid item xs={12} md={6}>
            <Card sx={{ p: 3, borderRadius: 2 }}>
              <Typography variant="h6" sx={{ mb: 2, color: BRAND_COLORS.darkGray }}>
                WhatsApp Service Status
              </Typography>
              <Box sx={{ mb: 2 }}>
                <Chip
                  label={waStatus}
                  color={waStatus === 'CONNECTED' ? 'success' : 'error'}
                  sx={{ fontSize: '1rem', px: 2, py: 1 }}
                />
              </Box>
              <Box sx={{ display: 'flex', gap: 2, mt: 2 }}>
                <Button
                  variant="outlined"
                  onClick={fetchStatusData}
                  disabled={loading}
                  sx={{ color: BRAND_COLORS.darkGray }}
                >
                  Refresh Status
                </Button>
                <Button
                  variant="outlined"
                  color="warning"
                  onClick={handleClearAuth}
                  disabled={clearingAuth}
                  sx={{ color: BRAND_COLORS.red }}
                >
                  {clearingAuth ? 'Clearing...' : 'Clear WhatsApp Auth'}
                </Button>
              </Box>
            </Card>
          </Grid>

          {/* System Health Card */}
          <Grid item xs={12} md={6}>
            <Card sx={{ p: 3, borderRadius: 2 }}>
              <Typography variant="h6" sx={{ mb: 2, color: BRAND_COLORS.darkGray }}>
                System Health
              </Typography>
              {healthData && (
                <Box>
                  <Box sx={{ mb: 1 }}>
                    <Chip
                      label={healthData.status?.toUpperCase() || 'UNKNOWN'}
                      color={healthData.status === 'ok' ? 'success' : 'error'}
                    />
                  </Box>
                  <Typography variant="body2" color="textSecondary">
                    Database: {healthData.database_status || 'Unknown'}
                  </Typography>
                  <Typography variant="body2" color="textSecondary">
                    WhatsApp Service: {healthData.whatsapp_service || 'Unknown'}
                  </Typography>
                  <Typography variant="body2" color="textSecondary">
                    Uptime: {Math.floor((healthData.uptime || 0) / 60)} minutes
                  </Typography>
                </Box>
              )}
            </Card>
          </Grid>

          {/* Detailed Status */}
          <Grid item xs={12}>
            <Card sx={{ p: 3, borderRadius: 2 }}>
              <Typography variant="h6" sx={{ mb: 2, color: BRAND_COLORS.darkGray }}>
                Detailed System Information
              </Typography>
              {statusData && (
                <Box
                  sx={{
                    backgroundColor: BRAND_COLORS.lightGray,
                    p: 2,
                    borderRadius: 1,
                    fontFamily: 'monospace',
                    fontSize: '0.9rem'
                  }}
                  dangerouslySetInnerHTML={{ __html: statusData.html }}
                />
              )}
            </Card>
          </Grid>
        </Grid>
      </Box>
    );
  }

  function QRView() {
    const [qrContent, setQrContent] = useState('');
    const [loading, setLoading] = useState(true);

    useEffect(() => {
      fetchQRCode();
      const interval = setInterval(fetchQRCode, 5000); // Refresh every 5 seconds
      return () => clearInterval(interval);
    }, []);

    const fetchQRCode = async () => {
      try {
        const response = await fetch('/qr');
        const html = await response.text();
        setQrContent(html);
      } catch (error) {
        console.error('Error fetching QR code:', error);
        setQrContent('<p>Error loading QR code</p>');
      } finally {
        setLoading(false);
      }
    };

    return (
      <Box sx={{ p: 3 }}>
        <Typography variant="h4" sx={{ mb: 3, color: BRAND_COLORS.darkGray }}>
          WhatsApp QR Code
        </Typography>
        <Card sx={{ p: 4, textAlign: 'center', borderRadius: 2 }}>
          {loading ? (
            <Box>
              <CircularProgress sx={{ mb: 2 }} />
              <Typography>Loading QR code...</Typography>
            </Box>
          ) : (
            <Box>
              <div dangerouslySetInnerHTML={{ __html: qrContent }} />
              <Box sx={{ mt: 3, display: 'flex', gap: 2, justifyContent: 'center' }}>
                <Button
                  variant="outlined"
                  onClick={fetchQRCode}
                  sx={{ color: BRAND_COLORS.darkGray }}
                >
                  Refresh QR Code
                </Button>
                <Button
                  variant="outlined"
                  onClick={() => window.open('/qr', '_blank')}
                  sx={{ color: BRAND_COLORS.darkGray }}
                >
                  Open in New Tab
                </Button>
              </Box>
            </Box>
          )}
        </Card>
      </Box>
    );
  }

  function AboutView() {
    return (
      <Box sx={{ p: 3 }}>
        <Paper sx={{ p: 4, textAlign: 'center', borderRadius: 2 }}>
          <Typography variant="h4" sx={{ mb: 2, color: BRAND_COLORS.darkGray }}>
            About WTF Intelligence
          </Typography>
          <Typography variant="body1" sx={{ color: BRAND_COLORS.mediumGray }}>
            About WTF Intelligence Platform v2.1
          </Typography>
        </Paper>
      </Box>
    );
  }
}
